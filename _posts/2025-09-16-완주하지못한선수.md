---
title: 프로그래머스 | 완주하지 못한 선수
date: 2025-09-16
categories:
- 코딩테스트
tags:
- solve
- 코딩테스트
- 알고리즘
- 자료구조
- Hash
- 프로그래머스 Level
---


## 1. 문제 정보

[문제링크](https://school.programmers.co.kr/learn/courses/30/lessons/42576?language=java)

난이도: Level 1

## 2. 풀이 접근

- 처음에는 Hash로 어떻게 해야할지 생각이 안나서 이중 for문 사용

    → 테스트는 통과하지만 효율성 테스트에서 시간초과 발생

- 시간복잡도 분석해봄

    N 크기가 100,000 이하

    이중 for문 시간복잡도 : $O(n^2)$ → 최대 100억 연산 (약 100초)

- Hash 구현체로 조회 시 시간복잡도 $O(1)$이므로 Hash 구현체를 어떻게 사용해볼지 고민해봄

- 동명이인을 관리해야하므로 HashMap에 name:count 형태로 저장하기로 함

## 3. 코드 및 설명

```java
import java.util.*;

class Solution {
    public String solution(String[] participant, String[] completion) {
        Map<String, Integer> map = new HashMap<>();
        for (String name : participant) {
            map.put(name, map.getOrDefault(name, 0)+1);
        }
        
        for (String name:completion) {
            map.put(name, map.get(name)-1);
        }
        
        String answer = "";
        for (String name : map.keySet()) {
            if (map.get(name) > 0) {
                answer = name;
            }
        }
        return answer;
    }
}
```

- 시간복잡도: $O(n)$
- 공간복잡도: $O(n)$

### 설명
    
우선 참가자 리스트(participant)를 Map으로 옮김
- key - name
- value - 해당 이름을 가진 사람 수

현재 인덱스의 이름이 이미 map에 저장되어 있는 경우 value 값을 1 증가 시킴

(getOrDefault 메서드를 통해 간단하게 구현 가능)

완주 선수 목록(completion)을 하나씩 map에서 존재하는지 확인

존재하는 선수 이름의 value를 1 감소

문제 조건에서 participant 길이와 completion 길이는 1 차이 이므로 map에 value가 1인 값은 하나만 남음

value가 0보다 큰 key를 출력

## 4. 느낀 점

처음에 getOrDefault 생각 못 하고 if 썼는데 Java 버전이 오를 수록 이런 기본 함수가 잘 만들어져있는 것 같다. 잘 기억해둬야겠다

문제 유형이 Hash인걸 알아서 HashMap을 썼지만 몰랐으면 이중for문에서 수정할 수 있었을지 모르겠다

조회 관련 문제에서 Hash 자료구조를 떠올릴 수 있도록 해야겠다

<br>
<br>

> 참고
>